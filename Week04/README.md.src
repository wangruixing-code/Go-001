*按照自己的构想，写一个项目满足基本的目录结构和工程，代码需要包含对数据层、业务层、API 注册，以及 main 函数对于服务的注册和启动，信号处理，使用 Wire 构建依赖。可以使用自己熟悉的框架。*

### 目录结构

```shell
├── Makefile        # 项目编译、运行、测试快捷命令
├── README.md
├── api             # rpc文件
│   └── user
│       └── v1
│           ├── user.pb.go
│           ├── user.proto
│           └── user_grpc.pb.go
├── bin
│   └── server      # 构建好的二进制文件
├── cmd
│   └── server      # 编译入口
│       ├── main.go
│       ├── wire.go
│       └── wire_gen.go
├── go.mod
├── go.sum
├── internal
│   ├── biz         # 业务组装层
│   │   └── user.go
│   ├── data        # 数据层
│   │   └── user.go
│   ├── pkg         # 公共库
│   │   └── grpc    # gRPC server封装
│   │       └── server.go
│   └── service     # API实现层
│       └── user.go
└── test            # 测试服务API
    └── user.go
```

### proto 定义

```go
syntax = "proto3";

package user.v1;

option go_package = "Week04/api/user/v1;v1";


service User {
  rpc RegisterUser (RegisterUserRequest) returns (RegisterUserReply) {}
}

message RegisterUserRequest {
  string name = 1;
  int32 age = 2;
}

message RegisterUserReply {
  int32 id = 1;
}
```

### 数据层 `data`

```go
// data/user.go

package data

import (
	"Week04/internal/biz"
	"log"
)

var _ biz.UserRepo = new(userRepo)

const (
	userID = 100
)

func NewUserRepo() biz.UserRepo {
	return &userRepo{}
}

type userRepo struct{}

func (r *userRepo) Save(u *biz.User) int32 {
	log.Printf("save user, name: %s, age: %d, id: %d", u.Name, u.Age, userID)
	return userID
}
```

### 业务组装层 `biz`

```go
// biz/user.go

package biz

type User struct {
	ID   int32
	Name string
	Age  int32
}

type UserRepo interface {
	Save(*User) int32
}

func NewUserUsecase(repo UserRepo) *UserUsecase {
	return &UserUsecase{repo: repo}
}

type UserUsecase struct {
	repo UserRepo
}

func (s *UserUsecase) SaveUser(u *User) {
	id := s.repo.Save(u)
	u.ID = id
}
```

### API实现层 `service`

```go
// service/user.go

package service

import (
	v1 "Week04/api/user/v1"
	"Week04/internal/biz"
	"context"
)

type UserService struct {
	u *biz.UserUsecase
	v1.UnimplementedUserServer
}

func NewUserService(u *biz.UserUsecase) v1.UserServer {
	return &UserService{u: u}
}

func (s *UserService) RegisterUser(ctx context.Context, r *v1.RegisterUserRequest) (*v1.RegisterUserReply, error) {
	// dto -> do
	u := &biz.User{Name: r.Name, Age: r.Age}

	// call biz
	s.u.SaveUser(u)

	// return reply
	return &v1.RegisterUserReply{Id: u.ID}, nil
}
```

### RPC Server封装

```go
// pkg/grpc/server.go

package grpc

import (
	"context"
	"log"
	"net"

	"google.golang.org/grpc"
)

type Server struct {
	*grpc.Server

	address string
}

func NewServer(address string) *Server {
	srv := grpc.NewServer()
	return &Server{Server: srv, address: address}
}

func (s *Server) Start(ctx context.Context) error {
	l, err := net.Listen("tcp", s.address)
	if err != nil {
		return err
	}

	log.Printf("grpc server start: %s", s.address)

	go func() {
		<-ctx.Done()
		s.GracefulStop()
		log.Printf("grpc server gracefull stop")
	}()

	return s.Serve(l)
}
```

### 启动入口

#### `cmd/server/wire.go`

```go
//+build wireinject 忽略编译

package main

import (
	"Week04/internal/biz"
	"Week04/internal/data"

	"github.com/google/wire"
)

func InitUserUsecase() *biz.UserUsecase {
	wire.Build(biz.NewUserUsecase, data.NewUserRepo)
	return &biz.UserUsecase{}
}
```

#### `cmd/server/wire_gen.go`

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"Week04/internal/biz"
	"Week04/internal/data"
)

// Injectors from wire.go:

func InitUserUsecase() *biz.UserUsecase {
	userRepo := data.NewUserRepo()
	userUsecase := biz.NewUserUsecase(userRepo)
	return userUsecase
}
```

#### `cmd/server/main.go`

```go
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"

	pb "Week04/api/user/v1"
	"Week04/internal/pkg/grpc"
	"Week04/internal/service"

	"golang.org/x/sync/errgroup"
)

const (
	address = ":9800"
)

func main() {
	// init service api
	us := InitUserUsecase()
	service := service.NewUserService(us)

	// register grpc service
	s := grpc.NewServer(address)
	pb.RegisterUserServer(s, service)

	// context
	ctx, cancel := context.WithCancel(context.Background())
	g, ctx := errgroup.WithContext(ctx)

	// start grpc server
	g.Go(func() error {
		return s.Start(ctx)
	})

	// catch signals
	g.Go(func() error {
		sigs := make(chan os.Signal, 1)
		signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
		select {
		case sig := <-sigs:
			log.Printf("signal caught: %s, ready to quit...", sig.String())
			cancel()
		case <-ctx.Done():
			return ctx.Err()
		}
		return nil
	})

	// wait stop
	if err := g.Wait(); err != nil {
		log.Printf("error: %v", err)
	}
}
```

### 启动 RPC 服务

```shell
make build  # 构建二进制
make run    # 启动服务 (./bin/server)
```

RPC 服务启动，输出日志：

```shell
2020/12/16 01:07:06 grpc server start: :9800
```

测试 RPC 接口：

```shell
make rpc    // 执行 go run test/user.go
```

输出日志：

```shell
// 调服务端 RPC 接口 模拟注册一个用户
2020/12/16 01:16:21 register user id: 100
```

### 服务停机

按下 `ctrl + c`，服务优雅停机，输出日志：

```shell
2020/12/16 01:16:17 grpc server start: :9800
2020/12/16 01:16:21 save user, name: zhangsan, age: 20, id: 100
2020/12/16 01:16:24 signal caught: interrupt, ready to quit...
2020/12/16 01:16:24 grpc server gracefull stop
```
